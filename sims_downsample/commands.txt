# using called SNPs and genotypes for high-coverage bees:
# ancestry reference pops: Harpur A, C, and M bees
# admixed bees: Riverside_2014 (n=8)
# original data: from Julie, in data/bees_new_positions/ALL.bam ALL.fam ALL.map
# note: the original positions in ALL.map are incorrect because gaps between scaffolds are skipped
# over for physical positions and recombination/genetic distance was calculated
# with a chromosomal mean recombination rate. I will need to recalculate.

# total number of SNPs passing Julie's filtering:
data/bees_new_positions$ wc -l ALL.map
5781640 ALL.map

# create a file where 3rd column is population label (to filter by in plink)
data/bees_new_positions$ awk '{print $1, '\t', $2, '\t', $1}' ALL.fam > populations.txt

# get allele frequencies for Harpur A, C and M
data/bees_new_positions$ for pop in A M C; do plink --bfile ALL --freq --keep-allele-order --filter populations.txt $pop --out $pop; done
# note that --keep-allele-order preserves original ref/alt allele from ALL.bed (not necessarily related to reference allele in bee reference genome (!))
# taking out freq. column to stick all pop freqs together
awk '$1!="CHR" {print $1, '\t', $2, '\t', $3, '\t', $4, '\t', $5}' A.frq > A.frq.temp
for pop in M C; do awk '$1!="CHR" {print $5}' $pop.frq > $pop.frq.temp; done
# make header
echo CHR$'\t'SNP$'\t'A1$'\t'A2$'\t'A$'\t'C$'\t'M > ACM.frq
# paste them together
paste A.frq.temp C.frq.temp M.frq.temp -d '\t' >> ACM.frq
# remove temporary files
rm *.frq.temp
#rm [ACM].frq

# positions with under 0.2 minor allele frequency in all 3 populations offer little ancestry information, so I filter those out
data/bees_new_positions$ awk '$7 >= 0.2 || $6 >= 0.2 || $5 >= 0.2 {print $0}' ACM.frq | wc -l
# 648636
# This leaves about 650k SNPs. I did not filter for differences between ancestries because I didn't want to bias my results for SNPs informative C-M but not, for example A-C which has lower Fst
data/bees_new_positions$ head -n1 ACM.frq > ACM_common.frq
data/bees_new_positions$ awk '$7 >= 0.2 || $6 >= 0.2 || $5 >= 0.2 {print $0}' ACM.frq >> ACM_common.frq


# Then I filter for SNPs with high LD in the A population using plink and a sliding window of 50 SNPs
# greedily removing SNPs until no pairs in the window have r^2 > .4 , then shifting the window by 10 SNPs
bees_new_positions$ plink --bfile ALL --indep-pairwise 50 10 0.4 --keep-allele-order --extract ACM_common.frq --filter populations.txt A --out lowLDA4

# this leaves 160k SNPs
bees_new_positions$ wc -l lowLDA4.prune.in161036 lowLDA4.prune.in

# now I get allele counts for Harpur A C M for those positions (and I put all the lowLD files in a folder) lowLDA4
data/bees_new_positions$ for pop in A C M; do plink --bfile ALL --freq counts --keep-allele-order --extract lowLDA4/lowLDA4.prune.in --filter populations.txt $pop --out lowLDA4/$pop; done

# I also try an alternative windowed approach to filter SNPs:
# The idea is that on average LD decays quickly in honeybees and in all major groups A, C, M and O, mean r^2 is below 0.1 at greater than 1.5 kb https://www.nature.com/articles/ng.3077/figures/8 .
# Based on this information, I only look for r^2 above 0.2 in the African population in widows length 1.5 kb to avoid chance spurious results at unreasonably great distances
data/bees_new_positions$ plink -bfile ALL --indep-pairwise 1.5 kb 1 0.2 --keep-allele-order --extract ACM_common.frq --filter populations.txt A --out newlowLDA2/snps

# now I get allele counts for each individual in Riverside_2014 for those same alleles.
# to do this, I first make a new file with 3rd column identifying samples by individual ID
data/bees_new_positions$ awk '{print $1, '\t', $2, '\t', $2}' populations.txt > individuals.txt
# then for each individual in riverside_2014, I make an allele counts file
data/bees_new_positions$ for ind in $(awk '$1 == "Riverside_2014" {print $2}' individuals.txt); do plink --bfile ALL --freq counts --keep-allele-order --extract lowLDA4/lowLDA4.prune.in --filter individuals.txt $ind --out lowLDA4/$ind; done
# these are now saved as, e.g. SRCD49A.frq.counts where columns C1 and C2 identify counts for allele A1 and A2 and column G0 counts missing genotypes (C1 + C2 + G0 = 2 for each individual)

# now I get physical positions relative to chromosome (not scaffold; assumes 50,000 bp gaps between scaffolds)
# and the recombination distance between positions based on Wallberg recombination map for each position 
# at 100,000 resolution (could go down to 10,000 or lower, but some smoothing is likely more accurate). 
# Note: As I understand it, this map skips over gaps between scaffolds as if the gaps take up 50kbp and it's contiguous sequence 
# (same with bp position for v4.5 genome). The lower resolution maps do the same, but omit a recombination rate for any window 
# bridging scaffolds as it's not estimated well. I impute these recombination rates using the average rate across all non-NA windows in the chromosome
Rscript bp_to_r_Wallberg2015.R data/bees_new_positions/lowLDA4/A.frq.counts

# now I merge all the files to the correct format for ancestry_hmm
# chromosome, position_bp, allele counts A1 in A, allele counts A2 in A, allele counts A1 in C, allele counts A2 in C, allele counts A1 in M, allele counts A2 in M,
# distance in Morgans between previous marker and this one
# read counts A1 in sample1, read counts A2 in sample1, read counts A1 in sample2 etc.
infX.counts.pos

# I also create the sample input file for ancestry_hmm specifying ploidy
Riv2014.sample.ploidy
sample1\t2
sample2\t2 etc.

# I run NGSadmix on A, C, M reference pops and riverside 2014 individuals using reduced SNPs (pruned for LD) to get approximate population admixture proportions for each contributing ancestry
# to run NGSadmix I need beagle genotype likelihoods for all individuals, which I create in ANGSD

# now I run ancestry_hmm, allowing it to estimate time since admixture between 2 and 60 generations (1-2 yrs/gen & admixture after 1957 - present/2014 sample)
# -g indicates that called genotypes (allele counts), rather than read counts, are being used for admixed individuals 
# -a 3 0.4 0.4 0.2
# population C 100 gen (est.) receives M migrants then 60 gen (est.) receives second wave of A migrants
# -p 1 100000 0.4 -p 2 100 0.2 -p 0 -30 0.4 --tmax 60 --tmin 2
# --ne ?not_sure

# I binomially sample 'reads' for coverage and re-run ancestry_hmm
1X.counts.pos, 2X.counts.pos, 4X.counts.pos, 6X.counts.pos etc.
