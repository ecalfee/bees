# Inferring local ancestry across the honeybee genome

# ancestry_hmm:

# Use SNPs filtered to 1000 bp to avoid within-ancestry LD.
# Filtered SNPs are chosen to have high ancestry informativeness,
# defined by at least A C or M having minor allele freq > 30%
local_ancestry$ mkdir -p results/SNPs/thin1kb_common3

# find allele frequencies in plink (see sims_downsample/commands.txt) - saved as data/bees_new_positions/ACM.frq:

# find 'ancestry informative' positions with >= .3 minor allele frequency in at least one population:
local_ancestry$ awk '$7 >= 0.3 || $6 >= 0.3 || $5 >= 0.3 {print $0}' ../data/bees_new_positions/ACM.frq | wc -l
# This leaves about 500k SNPs. Make a new file with just these ancestry informative 'common SNPs'
local_ancestry$ awk '$7 >= 0.3 || $6 >= 0.3 || $5 >= 0.3 {print $0}' ../data/bees_new_positions/ACM.frq > results/SNPs/ACM_common3.frq

# Using plink, filter this SNP set to >1kb spacing, because A, C, M groups have LD < .15 and ind. populations have LD < .2 at this distance (most sig. less): https://www.nature.com/articles/ng.3077/figures/8.
local_ancestry$ plink --bfile ../data/bees_new_positions/ALL --write-snplist \
--keep ../data/bees_new_positions/noYorCeranaorDomestic.txt --keep-allele-order \
--extract results/SNPs/ACM_common3.frq --bp-space 1000 --out SNPs/thin1kb_common3/included
# the result is ~120k SNPs saved in results/SNPs/thin1kb_common3/included.snplist

# Get called genotype counts at all SNPs for A, C, and M groups at each SNP
local_ancestry$ for pop in A C M; do plink --bfile ../data/bees_new_positions/ALL --freq counts --keep-allele-order --extract results/SNPs/thin1kb_common3/included.snplist --filter ../data/bees_new_positions/populations.txt $pop --out results/SNPs/thin1kb_common3/$pop; done
# strip header and other information besides allele counts from .frq.counts files
local_ancestry$ for i in $(ls results/SNPs/thin1kb_common3/*.frq.counts); do awk '$1!="CHR" {print $5"\t"$6}' $i > $i.strp; done

# Get read counts for each admixed individual at every SNP included
# First, make a sites file of the scaffold, bp position on the scaffold, and maj/min allele for ANGSD input
local_ancestry$ tail -n +2 results/SNPs/thin1kb_common3/A.frq.counts | tr "." "\t" | \
awk '{print $3"."$4"\t"$5"\t"$6"\t"$7}' > results/SNPs/thin1kb_common3/included.var.sites
# index this file for angsd:
local_ancestry$ angsd sites index results/SNPs/thin1kb_common3/included.var.sites
# now getting read counts for maj/min alleles at these sites for each admixed individual:
# First I get counts of all reads A/C/G/T for each site using ANGSD:
local_ancestry$ nohup parallel --joblog logs/ACGTcounts_novo_seq_1.log --noswap --jobs 4 './countReadsACGT.sh {1} thin1kb_common3'\
 :::: ../data/novo_seq/C202SC18101772/samples.list &> logs/ACGTcounts_novo_seq_1.out &
[1] 24962 - COMPLETED 2.12.19 (fast)

# then using R I convert A/C/G/T counts into maj/min allele counts:
local_ancestry$ nohup parallel --joblog logs/getMajMinCounts_C202SC18101772.log 'Rscript ./getMajorMinorReadCountsFromACGT.R {1} thin1kb_common3' :::: ../data/novo_seq/C202SC18101772/samples.list &> logs/getMajMinCounts_C202SC18101772.out &
[1] 30182 - COMPLETED 2.14.19 (fast)

# Make a sites file with bp position and recombination position relative to the chromosome
local_ancestry$ Rscript ./bp_to_r_Wallberg2015.R thin1kb_common3 A.rates.1000.201.low_penalty.csv.cM_Mb.windows.100000.csv

# Combine counts and SNP information into input files for ancestry_hmm:
# paste together stripped files into correct order for ancestry_hmm input file
# chromosome, position_bp, allele counts A1 in A, allele counts A2 in A, allele counts A1 in C, allele counts A2 in C, allele counts A1 in M, allele counts A2 in M,
# distance in Morgans between previous marker and this one
# read counts A1 in sample1, read counts A2 in sample1, read counts A1 in sample2 etc.
local_ancestry/results/SNPs/thin1kb_common3$ paste included.pos A.frq.counts.strp C.frq.counts.strp M.frq.counts.strp included.rdist $(for i in $(cat ../../../../data/novo_seq/C202SC18101772/samples.list); do echo countsMajMin/"$i".counts.txt; done) > ACM_pass1_2018.counts

# make a ploidy file including all admixed individuals being analyzed:
local_ancestry/results/SNPs/thin1kb_common3$ awk '{print $0"\t2"}' ../../../../data/novo_seq/C202SC18101772/samples.list > pass1_2018.ploidy



# Run ancestry_hmm
# First I pulled the git and installed the latest version v0.94. 'make' in that subfolder and copied it as ancestry_hmm_v0.94 to my ~/bin
# (0) ran test run first with no bootstrapping and fixed admixture times at 60 (C-M) and 30 (A) generations back:
local_ancestry/results/ancestry_hmm/thin1kb_common3/pass1_2018_0.4_0.4_0.2$ ancestry_hmm_v0.94 -e 3e-3 -a 3 0.4 0.4 0.2 -p 1 100000 0.4 -p 2 60 0.2 -p 0 30 0.4 --ne 670000 -i ../../../SNPs/thin1kb_common3/ACM_pass1_2018.counts -s ../../../SNPs/thin1kb_common3/pass1_2018.ploidy
# Saved command log from above (ancestry_hmm_log.txt) and posterior results in 
local_ancestry/results/ancestry_hmm/thin1kb_common3/pass1_2018_0.4_0.4_0.2/fixed_t_60_30/

# (0) Very confusingly, the results above suggest that X2.0.0 is C, X0.2.0 is MM and X0.0.2 is AA genotypes 
# when I've specified that pop 0 is A, pop 1 is C and pop 2 is M. So I am rerunning now where I put my admixture
# events in the same order that I specify my ancestries (start with p0, then p1, then p2) 
# (!) If this is a problem, it could mean my simulation results aren't quite labelled correctly for the diff. ancestries.
local_ancestry/results/SNPs/thin1kb_common3$ paste included.pos C.frq.counts.strp M.frq.counts.strp A.frq.counts.strp included.rdist $(for i in $(cat ../../../../data/novo_seq/C202SC18101772/samples.list); do echo countsMajMin/"$i".counts.txt; done) > CMA_pass1_2018.counts - DONE
local_ancestry/results/ancestry_hmm/thin1kb_common3/pass1_2018_0.4_0.4_0.2/reverse_order_CMA$ ancestry_hmm_v0.94 -e 3e-3 -a 3 0.4 0.2 0.4 -p 0 100000 0.4 -p 1 60 0.2 -p 2 30 0.4 --ne 670000 -i ../../../SNPs/thin1kb_common3/CMA_pass1_2018.counts -s ../../../SNPs/thin1kb_common3/pass1_2018.ploidy



# (1) run ancestry_hmm with all bees together and a few reasonable ancestry estimates:
# 40% A freq, 40% C and 20% M prior (approx middle A ancestry, e.g. S. CA)
# 10% A freq, 70% C and 20% M prior (approx low A ancestry)
# 70% A freq, 5% C and 25% M prior (approx high A ancestry)
# as well as a few extreme priors to test sensitivity 
# (one ancestry @ 90% and all others at 5%)
local_ancestry$ nohup parallel --noswap --joblog logs/ancestry_hmm_thin1kb_pass1_2018.log \
'mkdir -p results/ancestry_hmm/{1}/pass1_2018_{2}_{3}_{4}; \
cd results/ancestry_hmm/{1}/pass1_2018_{2}_{3}_{4}; \
ancestry_hmm_v0.94 -e 3e-3 -a 3 {2} {3} {4} \
-p 1 100000 {3} -p 2 -100 {4} -p 0 -60 {2} \
--tmax 150 --tmin 2 --ne 670000 \
-b 10 1000 \
-i ../../../SNPs/{1}/ACM_pass1_2018.counts -s ../../../SNPs/{1}/pass1_2018.ploidy' \
::: thin1kb_common3 ::: 0.4 0.7 0.1 0.05 0.05 0.9 :::+ 0.4 0.05 0.7 0.9 0.05 0.05 :::+ 0.2 0.25 0.2 0.05 0.9 0.05 \
&> logs/ancestry_hmm_thin1kb_pass1_2018.out & 
# notes: order of ancestries is A {2} C {3} M {4}
# -b 10 1000 does bootstraps for time
# estimating admixture times starting at 100 generations ago for C-M and 60 generations for A-(C/M)
# but possible range 2 generations to 100 generations
# results are output to the working directory (hence directory change)
[1] 20098 - RUNNING 2.13.19 (Killed - no memory usage; input file had a problem). fixed & rerunning:
[1] 30771 (Killed - problem was I left out M frequencies from input file.) fixed & rerunning:
[1] 31237 - RUNNING 2.14.19 (KILLED due to memory issues -- I need to limit memory and also perhaps the search for admixture timing:
local_ancestry$ nohup parallel --noswap --jobs 3 --joblog logs/ancestry_hmm_thin1kb_pass1_2018_fixt1.log \
'mkdir -p results/ancestry_hmm/{1}/pass1_2018_{2}_{3}_{4}; \
cd results/ancestry_hmm/{1}/pass1_2018_{2}_{3}_{4}; \
ancestry_hmm_v0.94 -e 3e-3 -a 3 {2} {3} {4} \
-p 1 100000 {3} -p 2 100 {4} -p 0 -60 {2} \
--tmax 80 --tmin 10 --ne 670000 \
-b 10 1000 \
-i ../../../SNPs/{1}/ACM_pass1_2018.counts -s ../../../SNPs/{1}/pass1_2018.ploidy' \
::: thin1kb_common3 ::: 0.4 0.7 0.1 0.05 0.05 0.9 :::+ 0.4 0.05 0.7 0.9 0.05 0.05 :::+ 0.2 0.25 0.2 0.05 0.9 0.05 \
&> logs/ancestry_hmm_thin1kb_pass1_2018_fixt1.out & 
[1] 31990 - RUNNING 2.14.19. Finished. When I fix t1 C-M admixture at 100 generations, and run all samples together,
estimates for t2 (A admixture) fall between 10 and 20 generations, which seems low but could be due to ongoing gene flow
or artefacts of mixing all the samples together or of setting t1 too high (to 100 generations).

# TO DO:

# (2) run ancestry_hmm for different groups separately, grouping bees into larger 'populations' based on roughly similar global ancestry proportions
# groups: 
# 40% A freq, 40% C and 20% M prior
# 10% A freq, 70% C and 20% M prior (approx low A ancestry)
N_AR_2018 # 70% A freq, 10% C and 20% M prior (Northern Argentina Samples)
M_AR_2018
S_AR_2018

N_CA_2018
S_CA_2018

# Verify general expected patterns
# look at estimated times since admixture and visualize some block lengths
# what portion of calls are heterozygous for ancestry? what portion are high confidence calls?
# how many of the LD-filtered SNPs, on average, fall within an ancestry block?
# do bees from the same hybrid zone have more similar local ancestry than across CA/Argentina?

# TO DO: I should update the bp positions in the ALL.bed file because some (short?) scaffolds are getting no SNPs, presumably because my LD filter is requiring 1000bp into the scaffold because it doesn't consider gaps between scaffolds. I could also then incorporate cM position into the SNPs file and extract genetic distances between SNPs, and recombination rates at each SNP, from plink
# TO DO: maybe I should be removing sites with > 2.5x mean ind. depth in R too, or likely triallelic sites where maj/min allele are very uncommon <.1 reads for a bee (plot and see if there's a peak)

# NOTE: I have a file from Andreas Wallberg about how to orient scaffolds to the genome to match the recombination map, but also some scaffolds are simply not oriented.
# This may affect estimates of t and local ancestry tracts significantly, so I’m rerunning local ancestry
# without putting scaffolds together into linkage groups (/ onto ‘chromosomes’)
# LG_to_ind_scaffolds_rmap_pos.R - make new position file base on local position and recomb rate
# making input file
bees/local_ancestry/results/SNPs/thin1kb_common3$ paste included_scaffolds.pos A.frq.counts.strp C.frq.counts.strp M.frq.counts.strp included_scaffolds.rdist $(for i in $(cat ../../../../data/novo_seq/C202SC18101772/samples.list); do echo countsMajMin/"$i".counts.txt; done) > ACM_pass1_2018_scaffolds.counts
# run ancestry_hmm:
nohup parallel --noswap --joblog logs/ancestry_hmm_thin1kb_pass1_2018_scaffolds.log \
'mkdir -p results/ancestry_hmm/{1}/pass1_2018_{2}_{3}_{4}_scaffolds; \
cd results/ancestry_hmm/{1}/pass1_2018_{2}_{3}_{4}_scaffolds; \
ancestry_hmm_v0.94 -e 3e-3 -a 3 {2} {3} {4} \
-p 1 100000 {3} -p 2 -100 {4} -p 0 -60 {2} \
--tmax 150 --tmin 2 --ne 670000 \
-b 10 1000 \
-i ../../../SNPs/{1}/ACM_pass1_2018_scaffolds.counts -s ../../../SNPs/{1}/pass1_2018.ploidy' \
::: thin1kb_common3 ::: 0.4 0.7 0.1 0.05 0.05 0.9 :::+ 0.4 0.05 0.7 0.9 0.05 0.05 :::+ 0.2 0.25 0.2 0.05 0.9 0.05 \
&> logs/ancestry_hmm_thin1kb_pass1_2018.out &
[1] 21649 - RUNNING 4.15.19. I need to check on this in the morning & see if it’s finishing or needs to have a fixed 100yr-back-C/M hybridization model?
